Option Explicit
Option Compare Text  ' Insensible à la casse

'====================================================
' UDF MultiLookup : recherche unique multi-critères et multi-retours
'
' Usage en cellule :
'   =MultiLookup(
'     TableRange,            ' Plage complète (en-tête 1re ligne + données en dessous)
'     CriteriaHeaders,       ' 1×N nom des colonnes à comparer
'     CriteriaValues,        ' 1×N valeurs correspondantes pour chaque ligne d'appel
'     ReturnColumns          ' 1×M nom(s) des colonne(s) dont on veut retourner la valeur
'   )
'
Public Function MultiLookup(
    TableRange As Range,
    CriteriaHeaders As Range,
    CriteriaValues As Range,
    ReturnColumns As Range
) As Variant
    Dim ws As Worksheet: Set ws = TableRange.Worksheet
    Dim hdrRow As Long: hdrRow = TableRange.Row
    Dim lastRow As Long: lastRow = hdrRow + TableRange.Rows.Count - 1
    Dim lastCol As Long: lastCol = TableRange.Column + TableRange.Columns.Count - 1
    Dim headerMap As Object: Set headerMap = CreateObject("Scripting.Dictionary")
    Dim i As Long, j As Long, rw As Long
    Dim critCount As Long, retCount As Long
    Dim matchOK As Boolean
    Dim foundRow As Long, foundCount As Long
    Dim critNames() As String, critValues() As String, retNames() As String
    Dim outputArr As Variant
    Dim callRng As Range, outRng As Range

    ' Déterminer nombre de critères et retours
    critCount = CriteriaHeaders.Cells.Count
    If CriteriaValues.Cells.Count <> critCount Then
        MultiLookup = CVErr(xlErrRef): Exit Function
    End If
    retCount = ReturnColumns.Cells.Count

    ' Vérifier zone de sortie libre sur la même ligne que la formule
    Dim callCell As Range, baseRow As Long, baseCol As Long
    On Error Resume Next: Set callCell = Application.Caller: On Error GoTo 0
    If Not callCell Is Nothing Then
        baseRow = callCell.Row
        baseCol = callCell.Column
        ' Vérifier que les cellules à droite jusqu'à baseCol+retCount-1 sont vides (hors formule)
        For j = 1 To retCount - 1
            With ws.Cells(baseRow, baseCol + j)
                If .HasFormula Or Not IsEmpty(.Value2) Then
                    MultiLookup = CVErr(xlErrRef)
                    Exit Function
                End If
            End With
        Next j
    End If
                End If
            End If
        Next c
    End If

    ' Construire le mapping entête -> index
    For j = TableRange.Column To lastCol
        headerMap(Trim(ws.Cells(hdrRow, j).Value)) = j
    Next j
    ' Lire noms et valeurs des critères
    ReDim critNames(1 To critCount): ReDim critValues(1 To critCount)
    For j = 1 To critCount
        critNames(j) = Trim(CStr(CriteriaHeaders.Cells(1, j).Value))
        critValues(j) = Trim(CStr(CriteriaValues.Cells(1, j).Value))
    Next j
    ' Lire noms des colonnes à retourner
    ReDim retNames(1 To retCount)
    For j = 1 To retCount
        retNames(j) = Trim(CStr(ReturnColumns.Cells(1, j).Value))
        If Not headerMap.Exists(retNames(j)) Then
            MultiLookup = CVErr(xlErrNA): Exit Function
        End If
    Next j

    ' Recherche ligne correspondante
    For rw = hdrRow + 1 To lastRow
        matchOK = True
        For j = 1 To critCount
            If Trim(ws.Cells(rw, headerMap(critNames(j))).Value) <> critValues(j) Then
                matchOK = False: Exit For
            End If
        Next j
        If matchOK Then
            foundCount = foundCount + 1
            foundRow = rw
            If foundCount > 1 Then
                MultiLookup = CVErr(xlErrValue): Exit Function
            End If
        End If
    Next rw

    If foundCount = 1 Then
        ReDim outputArr(1 To 1, 1 To retCount)
        For j = 1 To retCount
            outputArr(1, j) = ws.Cells(foundRow, headerMap(retNames(j))).Value
        Next j
        MultiLookup = outputArr
    Else
        MultiLookup = CVErr(xlErrNA)
    End If
End Function

' NOTE: Le reste des procédures d'installation MacroOptions reste inchangé
'====================================================
